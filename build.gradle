plugins {
  id "org.implab.gradle-typescript" version "1.0-SNAPSHOT"
}

// если версия явно не заданы вычисляем ее из тэга ревизии v.{num}***
// результатом будет версия '{num}.{distance}' где distance - расстояние от
// текущей ревизии до ревизии с тэгом
def tagDistance = 0;
def isRelease = false;

if (!version) {
    
    def rev = ["hg", "log", "-r", ".", "--template", "{latesttag('re:^v') % '{tag}-{distance}'}"].execute().text.trim();

    def tagVersion;

    def match = (rev =~ /^v(\d+\.\d+\.\d+).*-(\d+)$/);
    
    if (match.size()) {
        tagVersion = match[0][1];
        tagDistance = match[0][2].toInteger();
    } else {
        throw new Exception("A version must be specied");
    }

    version = tagVersion;

    if (tagDistance > 0)
        version++;
} else {
    println "explicit version: $version";
}

if (hasProperty('versionSuffix') && versionSuffix) {
    version += "-$versionSuffix"
}

if(!npmName)
    npmName = name;

if (hasProperty('release')) {
    isRelease = (release != 'false')
} else {
    isRelease = (tagDistance == 0);
}

if(!["amd", "commonjs", "system", "umd", "es6", "esnext"].contains(jsmodule))
    throw new Exception("Invalid jsmodule specified: $jsmodule");
if(!["es3", "es5", "es6", "es2016", "es2017", "esnext"].contains(target))
    throw new Exception("Invalid target specified: $target")

def targetLibs = [
    "es3" : ["es5", "es2015.promise", "es2015.symbol", "dom", "scripthost"],
    "es5" : ["es5", "es2015.promise", "es2015.symbol", "dom", "scripthost"]
];

ext {
    packageName = "@$npmScope/$npmName"
}

def srcDir = "$projectDir/src"
def typingsDir = "$srcDir/typings"
def distDir = "$buildDir/dist"
def testDir = "$buildDir/test"
def jstarget = target;

sources {

}

typescript {
    compilerOptions {
        lib = targetLibs[target] ?: [target, "dom"]
        target = jstarget
        module = jsmodule
        types = []
    }
    tsLintCmd = "tslint"
	esLintCmd = "eslint"
	npmCmd = "npm"
}

task printVersion {
    doLast {
        println "version: $version";
        println "isRelease: $isRelease, tagDistance: $tagDistance";
        println "packageName: $packageName";
        println "bundle: ${pack.outputs.files.join(',')}";
        println "target: $target";
        println "module: $jsmodule";
    }
}

task clean {
    doLast {
        delete buildDir
        delete typingsDir
    }
}

task _initBuild {
    mustRunAfter clean

    def buildInfoFile = "$buildDir/platform";
    inputs.property('target',target);
    inputs.property('jsmodule',jsmodule);
    outputs.file(buildInfoFile);

    doLast {
        delete buildDir
        mkdir buildDir

        def f = new File(buildInfoFile);
        f << "$target-$jsmodule";
    }
}

/*
task _installLocalCjsDependency(dependsOn: [buildTestCjs, "_packageMeta"], type: Exec) {
    inputs.file("$distDir/package.json")
    outputs.upToDateWhen {
        new File("$testDir/$packageName").exists()
    }

    workingDir testDir

    commandLine 'npm', 'install', '--no-save', '--force', distDir
}

task _test(dependsOn: [buildTest], type: Exec) {
    if (jsmodule == "amd")
        dependsOn buildTestAmd
    if (jsmodule == "commonjs") {
        dependsOn buildTestCjs
        dependsOn _installLocalCjsDependency
    }

    commandLine 'node', "$testDir/run-tests.js"
}
*/

task markRelease(type: Exec) {
    onlyIf { tagDistance > 1 }
    commandLine "hg", "tag", "v$version";
}